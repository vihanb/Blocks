/* Generated by Babel */
// Classes
"use strict";

var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; })();

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Point = function Point() {
  var x = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
  var y = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

  _classCallCheck(this, Point);

  this.x = x;
  this.y = y;
};

var Range = function Range() {
  _classCallCheck(this, Range);
};

var Matrix = (function () {
  function Matrix() {
    var x = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];
    var y = arguments.length <= 1 || arguments[1] === undefined ? 1 : arguments[1];

    _classCallCheck(this, Matrix);

    this.Matrix = Array(+y).fill("").map(function () {
      return Array(+x).fill("");
    });
  }

  _createClass(Matrix, [{
    key: "toString",
    value: function toString() {
      var x = arguments.length <= 0 || arguments[0] === undefined ? " " : arguments[0];
      var y = arguments.length <= 1 || arguments[1] === undefined ? "\n" : arguments[1];
      return this.Matrix.map(function (Row) {
        return Row.join(x);
      }).join(y);
    }
  }, {
    key: "set",
    value: function set(x, y, value) {
      if (x instanceof Point) this.Matrix[x.y][x.x] = y;else this.Matrix[y][x] = value;
    }
  }, {
    key: "fill",
    value: function fill(range) {
      return this;
    }
  }, {
    key: "expand",
    value: function expand(x, y) {
      var _this = this;

      this.Matrix = Array(+y).fill(Array(+x).fill("")).map(function (Column, IndexY) {
        return Column.map(function (_, IndexX) {
          return (_this.Matrix[IndexY] || [])[IndexX] || _;
        });
      });
    }
  }, {
    key: "each",
    value: function each(func) {
      return this.Matrix.map(function (Row, Y) {
        return Row.map(function (Value, X) {
          return func(Value, new Point(X, Y));
        });
      });
    }
  }, {
    key: "map",
    value: function map(func) {
      this.Matrix = this.each(func);return this;
    }
  }]);

  return Matrix;
})();

var Handle = {
  // == Items ==
  // CastString
  // AlignLeft
  // AlignRight

  CastString: function CastString(matrix) {
    return matrix.map(function (Value) {
      return (Value + "").trim();
    });
  },

  AlignLeft: function AlignLeft(matrix) {
    var _ref;

    // Assuming matrix instance of Matrix
    var Length = Math.max.apply(Math, _toConsumableArray((_ref = []).concat.apply(_ref, _toConsumableArray(matrix.each(function (Value) {
      return +Value.length;
    })))));
    return matrix.map(function (Value) {
      return Value + " ".repeat(Length - Value.length);
    });
  },
  AlignRight: function AlignRight(matrix) {
    var _ref2;

    var Length = Math.max.apply(Math, _toConsumableArray((_ref2 = []).concat.apply(_ref2, _toConsumableArray(matrix.each(function (Value) {
      return +Value.length;
    })))));
    return matrix.map(function (Value) {
      return " ".repeat(Length - Value.length) + Value;
    });
  }
};

var Blocks = function Blocks(code, inputs, opts) {
  // Setup

  var _code$split = code.split(":");

  var _code$split2 = _toArray(_code$split);

  var SetupSize = _code$split2[0];
  var SetupOpt = _code$split2[1];

  var SetupCode = _code$split2.slice(2);

  SetupCode = SetupCode.join(":");

  // Main data
  var MainMatrix = new Matrix(0, 0); // Matrix
  var MainVars = {}; // Variables

  /*=== SETUP START ===*/

  var _SetupSize$match = SetupSize.match(/(?:\d+|\?)/g);

  var _SetupSize$match2 = _slicedToArray(_SetupSize$match, 2);

  var SetupSizeX = _SetupSize$match2[0];
  var SetupSizeY = _SetupSize$match2[1];

  if (SetupSizeY) MainMatrix.expand(SetupSizeX, SetupSizeY);else if (SetupSizeX !== "?") MainMatrix.expand(SetupSizeX, SetupSizeX);

  /*=== OPTIONS START ===*/
  var Options = {
    $S: Handle.CastString,

    a: Handle.AlignLeft,
    A: Handle.AlignRight
  };
  var OptsDefault = ["$S"]; // CastString
  var Opts = function Opts() {
    return [].concat(_toConsumableArray(SetupOpt), OptsDefault).forEach(function (opt) {
      var Response = MainOptions[opt](MainMatrix);
      if (Response) MainMatrix = Response;
    });
  };

  /*=== PARSING START  ===*/
  var Code = SetupCode;

  // The reason I'm using a 2D array is that Map doesn't allow duplicates so $n|Fib can't be used twice
  var CodeTokens = []; // [Statement Body, Statement Name]

  // Parsing Closures
  // Contains all the data needed for parsing
  {
    (function () {
      var Location = 0; // Negative represents a header,
      var StatementHead = "";
      var StatementBody = "";

      var StatementBodyIgnoreIndex = -1;
      var StatementBodyIgnoreLiteral = "";

      var StatementBodyIgnore = ["\"\"\\", "''\\"]; // Start, End, Escape. If Escape === End, no escape
      var StatementBodyIgnoreStart = StatementBodyIgnore.map(function (group) {
        return group[0];
      });
      var StatementBodyIgnoreEnd = StatementBodyIgnore.map(function (group) {
        return group[1];
      });
      var StatementBodyIgnoreEscape = StatementBodyIgnore.map(function (group) {
        return group[2];
      });

      var StatementReset = function StatementReset() {
        StatementBody = StatementHead = StatementBodyIgnoreLiteral = "";StatementBodyIgnoreIndex = -1;Location = 0;
      };

      // Maximum Variables
      var MAX_ESCAPE = 65536; // 2^16
      var MAX_NESTED = 256; // 2 ^ 8
      var MAX_NUMLEN = 16;

      // Parsing Closure - A
      // Simplified the input to a bare representation
      {
        for (var i = 0; i < Code.length; i++) {
          var Char = Code[i];
          if (Location >= 0) {
            // Statement Body
            if (StatementBodyIgnoreStart.includes(Char)) {
              StatementBodyIgnoreIndex = StatementBodyIgnoreStart.indexOf(Char);
              StatementBodyIgnoreLiteral = StatementBodyIgnoreEnd[StatementBodyIgnoreIndex] === StatementBodyIgnoreEscape[StatementBodyIgnoreIndex] ? "" : StatementBodyIgnoreEnd[StatementBodyIgnoreIndex];
              StatementBody += Code[i++];

              // If length < MAX_ESCAPE, and Char is not the statement end
              for (var j = i; i - j < MAX_ESCAPE && Code[i] !== StatementBodyIgnoreEnd[StatementBodyIgnoreIndex]; i++) {
                StatementBody += Code[Code[i] === StatementBodyIgnoreLiteral ? // Is The escape character?
                ++i : i // Yes? increment i No? i
                ];
                if (i - j + 1 === MAX_ESCAPE) console.warn("Approaching Statement Maximum");
              }
              StatementBody += Code[i];
            } else if (/\|/.test(Char)) {
              // Is a "|" character
              Location = -1;
            } else if (/\S/.test(Char)) {
              // Not whitespace
              StatementBody += Char;
            }
          } else {
            // Statement Head
            if (/\S/.test(Char)) {
              // Not Whitespace
              if (Char === ";") {
                // End of Line
                CodeTokens.push([StatementBody, StatementHead]);
                StatementReset();
              } else {
                // Header Char
                StatementHead += Char;
              }
            }
          }
        }
      }

      // Temporary Operator Data
      var OperatorList = new Map([["+", function (left, right) {
        if (left === undefined) left = 0;
        return left + right;
      }], ["-", function (left, right) {
        if (left === undefined) left = 0;
        return left - right;
      }], ["/", function (left, right) {
        return left / right;
      }], ["*", function (left, right) {
        return left * right;
      }], ["%", function (left, right) {
        return left % right;
      }], ["^", function (left, right) {
        return Math.pow(left, right);
      }]]);
      var OperatorArity = [// Top is higher, bottom is lower
      ["^", "/", "*", "%"], ["-", "+"], [":"]].reverse();

      var OperatorMatchAll = new RegExp("[0-9()" + [].concat(_toConsumableArray(OperatorList.keys())).join("") + "]");
      var OperatorMatchOperator = new RegExp("[" + [].concat(_toConsumableArray(OperatorList.keys())).join("") + "]");

      // Parsing Closure B
      // This handles expressions and inserts the input
      // Handles order of operations and replaces ` with input
      {
        CodeTokens.map(function (_ref3) {
          var _ref32 = _slicedToArray(_ref3, 2);

          var CodeBody = _ref32[0];
          var CodeHeader = _ref32[1];

          for (var i = 0; i < CodeBody.length; i++) {
            var Char = CodeBody[i];
            // Ignore escapes
            if (StatementBodyIgnoreStart.includes(Char)) {
              StatementBodyIgnoreIndex = StatementBodyIgnoreStart.indexOf(Char);
              StatementBodyIgnoreLiteral = StatementBodyIgnoreEnd[StatementBodyIgnoreIndex] === StatementBodyIgnoreEscape[StatementBodyIgnoreIndex] ? "" : StatementBodyIgnoreEnd[StatementBodyIgnoreIndex];
              StatementBody += CodeBody[i++];

              // If length < MAX_ESCAPE, and Char is not the statement end
              for (var j = i; i - j < MAX_ESCAPE && CodeBody[i] !== StatementBodyIgnoreEnd[StatementBodyIgnoreIndex]; i++) {
                StatementBody += CodeBody[CodeBody[i] === StatementBodyIgnoreLiteral ? // Is The escape character?
                ++i : i // Yes? increment i No? i
                ];
                if (i - j + 1 === MAX_ESCAPE) console.warn("Approaching Statement Maximum");
              }
              StatementBody += CodeBody[i];
            } else if (OperatorList.has(Char)) {
              (function () {
                // Is an operator
                var OperatorValue = Char;
                var OperatorValueArity = OperatorArity.findIndex(function (Level) {
                  return Level.contains(OperatorValue);
                });

                var DataLeft = null;
                var DataRight = null;

                var ModLeft = null;
                var ModLeftStart = null;
                var ModLeftEnd = null;

                var ModRight = null;
                var ModRightStart = null;
                var ModRightEnd = null;

                var NewNestLevel = 0;
                var NewOperator = null;
                var NewDigit = null;

                ModLeftend = i - 1;
                ModRightStart = i + 1;
                // HALP I DONT KNOW HOW TO DO THIS
                for (var j = i; j > 0; j--) {
                  if (OperatorMatchAll.test(CodeBody[j])) {
                    if (OperatorMatchOperator.test(CodeBody[j])) {
                      // Operator encountered
                      NewOperator = OperatorArity.findIndex(function (Level) {
                        return Level.contains(OperatorValue);
                      });
                      if (NewOperator > OperatorArity) {} else if (NewOperator < OperatorArity) {} else if (NewOperator === OperatorArity) {}
                    } else if (/[\d]/.test(CodeBody[j])) {
                      // Digit encountered
                    } else if (CodeBody[j] === "(") {
                        // Open paranthesis
                      } else if (CodeBody[j] === ")") {
                          // Close parenthesis
                        }
                  } else {
                      // Not an operator character
                    }
                }
              })();
            } else {
                StatementBody += Char;
              }
          }
          return [CodeBody, CodeHeader];
        });
      }
      console.log(CodeTokens);
    })();
  }

  // Output
  return MainMatrix.Matrix.toString(" ", "\n");
};

Blocks.Golf = function (input, ungolf) {
  return input;
};
